<!DOCTYPE html>
<html lang="ru" class="hidden">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>About</title>
  <meta name="description" content="" />
  <meta name="keywords" content="" />
  <meta name="author" content="Dmitriy Bozhko / DIGIKRASH" />

  <!-- Favicon -->
  <link rel="icon" href="./favicon.png" type="image/png">

  <!-- Styles -->
  <link rel="stylesheet" href="./css/style-min.css">

  <style>

  </style>

  <!-- Preload -->
  <script>
    window.onload = function () {
      document.body.classList.add('loading');
      window.setTimeout(function () {
        document.body.classList.add('loaded');
        document.body.classList.remove('loading');
        document.documentElement.classList.remove('loading');
      }, 500);
      window.setTimeout(function () {
        document.documentElement.classList.remove('hidden');
      }, 1500);
    }
  </script>

</head>

<body class="about" data-barba="wrapper" data-scroll-container>

  @@include('./blocks/_preloader-page.html')

  <!-- barba loadind screen  -->
  @@include('./blocks/main/_barba-loading.html')

  <!-- header -->
  @@include('./blocks/main/_header.html')


  <main data-barba="container" data-barba-namespace="about">

    @@include('./blocks/main/_menu.html', {
    "home": "",
    "about": "active",
    "works": "",
    "contact": "",
    })


    <!-- top-about
    ======================================================= -->
    <section class="top-about" data-scroll-section>
      <div class="container">
        <div class="top-about__inner">
          <div class="top-about__titel">
            <h1 class="top-about__title1">
              <span><b>the highest</b></span>
              <span><b>pleasure</b></span>
            </h1>
            <h1 class="top-about__title2">
              <span><b>is</b></span>
              <span><b>Illusion</b></span>
            </h1>
          </div>
        </div>
        <div id="containerIslands">
          <canvas id="islands"></canvas>
        </div>

        <div class="lines">
          <svg class="line-wave" preserveAspectRatio="none" viewBox="0 0 340 160" version="1.1" xmlns="http://www.w3.org/2000/svg">
            <g>
              <path d="M0 80  C 30 10, 55 10, 85 80 S 140 150, 170 80 C 200 10, 225 10, 255 80 S 310 150, 340 80" />
            </g>
          </svg>
          <svg class="line-wave" preserveAspectRatio="none" viewBox="0 0 340 160" version="1.1" xmlns="http://www.w3.org/2000/svg">
            <g>
              <path d="M0 80  C 30 10, 55 10, 85 80 S 140 150, 170 80 C 200 10, 225 10, 255 80 S 310 150, 340 80" />
            </g>
          </svg>
          <svg class="line-wave" preserveAspectRatio="none" viewBox="0 0 340 160" version="1.1" xmlns="http://www.w3.org/2000/svg">
            <g>
              <path d="M0 80  C 30 10, 55 10, 85 80 S 140 150, 170 80 C 200 10, 225 10, 255 80 S 310 150, 340 80" />
            </g>
          </svg>
        </div>
      </div>
    </section>
    <!-- top-about end -->

    @@include('./blocks/main/_footer.html')

  </main>

  <!-- Global Scripts -->
  @@include('./blocks/main/_js.html')

  <!-- Libraries -->
  <script src="./locomotive-scroll.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js"></script>

  <!-- fps -->
  <script>
    javascript: (function () { var script = document.createElement('script'); script.onload = function () { var stats = new Stats(); document.body.appendChild(stats.dom); requestAnimationFrame(function loop() { stats.update(); requestAnimationFrame(loop) }); }; script.src = '//mrdoob.github.io/stats.js/build/stats.min.js'; document.head.appendChild(script); })()
  </script>
  <!-- preloader -->
  <script>
    $(document).ready(function () {
      const LANDING = {};
      LANDING.intro = document.querySelector(".preloader-page");
      LANDING.path = LANDING.intro.querySelector("path");

      const svgAnimation = () => {
        console.log("Animation");

        anime({
          targets: LANDING.intro,
          duration: 2000,
          easing: "easeInOutSine",
          translateY: "-200vh"
        });

        anime({
          targets: LANDING.path,
          duration: 1500,
          easing: "easeInOutSine",
          d: LANDING.path.getAttribute("pathdata:id")
        });
      };
      svgAnimation();
    })
  </script>
  <!-- Locomotive Scroll -->
  <script>
    // --- Locomotive Scroll (Smoth)
    const scroll = new LocomotiveScroll({
      el: document.querySelector('[data-scroll-container]'),
      smooth: true,
      smoothMobile: true,
    });
    scroll.destroy();
    document.addEventListener("DOMContentLoaded", function (event) {
      window.setTimeout(function () {
        scroll.init();
      }, 5500);
    });

    var a = {
      0: function () {
        scroll.stop();
      },

      1: function () {
        scroll.start();
      }
    }, b = -1;

    $('.menu-diamond').click(function () {
      a[++b % 2]()
    })
  </script>
  <!-- first screen texture -->
  <script id="fragment" type="x-shader/x-fragment">
    #define PI 3.14159265358979323846
    #define SAMPLES 200
  #define COUNT 2
    uniform vec2 uMouse;
    uniform vec2 uScreenMouse;
    uniform float uTime;
    
    uniform float oMovement;
    uniform float oLight;
      uniform float oStyle;
  
  
    varying vec2 vUv;
    
  mat2 rotate2d(float _angle){
      return mat2(cos(_angle),-sin(_angle),
                  sin(_angle),cos(_angle));
  }
   float scene(vec2 pos){
     float circle  = distance(vec2(0.),pos ) - 0.2;
     float freq = 5.;
      vec3 sParam = vec3(pos.x*freq , pos.y*freq , 0.1);
     if(oMovement == 0.)
      sParam.xy += uScreenMouse * 5.; 
      else if(oMovement == 1.)
      sParam.z += uTime; 
        
      
      float islands = snoise(sParam) * 0.5+0.5 -0.5;
     // Sum circle multipliefd making it 
     return  circle*2.5 + islands;
   }
    vec2 getLight(){
      
      vec2 lightPoint = uScreenMouse;
      if(oLight == 1.) 
        lightPoint = vec2(cos(uTime * 0.0),sin(uTime*0.0));
      if(oLight == 2.) 
        lightPoint = vec2(0.,0.);
      lightPoint = vec2(0.0) - lightPoint ;
      return lightPoint;
    }
    float lines(vec2 uv){
      
      vec2 rel = getLight();
      float angle = atan(rel.y, rel.x) + PI/2.;
      
      float totalLines = 60.;
      float s = 0.1;
      uv -=0.5;
      vec2 rotatedUV =  rotate2d(angle) * uv;
      float lines = fract(totalLines * rotatedUV.x);
      
      return lines;
    }
    float dots(vec2 uv){
      
      float nDots = 100.;
      float dot = fract(nDots * uv.x)* fract(nDots * uv.y) ;
      return dot;
    }
    float traceLines(vec2 position, vec2 direction){
      float rayProgress = 0.0;
      float lightDistance = 0.0;
      
      // return line;
      
      for(int i=0 ;i<SAMPLES; i++){
          float sceneDist = scene(position + direction * rayProgress);
  
          if(sceneDist <= 0.0){
            if(oStyle == 0.)
              return lines(position);
            if(oStyle == 1.)
              return lines(position)  * rayProgress/0.04 * (1.-rayProgress/0.08);
            position.x += sin(3.14 * (position.x+0.5));
            return 0.5;
          }
          if(rayProgress > lightDistance){
              // return clamp(nearest,0.0,1.0);
              return 0.0;
          }
  
          // nearest = min(nearest, sceneDist);
          rayProgress = rayProgress + float(i)/float(SAMPLES)*0.01;
      }
      return 1.;
      
    }
    float makeLine(float val, float aa){
      return smoothstep(0.-aa,0.,val) - smoothstep(0.,0.+aa,val);
    }
    void main(){
      vec2 uv = vUv;
      float mLen = distance(uv,uMouse);
      vec3 sParam = vec3(uv.x*5., uv.y*4., 0.1);
      
      float islands = smoothstep(0.5,0.55,(snoise(sParam) *0.5+0.5));
      float center =  distance(vec2(0.5),uv ) - 0.3;
      
      float smoothLines = lines(uv);
      // float shadeLines = distance
      float land = islands ;
      uv -= 0.5;
      float sdf = scene(uv);
      
      vec2 rel = getLight();
      float angle = atan(rel.y, rel.x) - PI;
   
      float shadowSDF = traceLines(uv, vec2(cos(angle), sin(angle)));
      float s = 0.2;
      float thinShadows = makeLine(shadowSDF-0.5, 0.2);
      
      float AA = 0.02;
      float inside = smoothstep(0.,0. -AA, sdf);
      float outside = smoothstep(0. + AA,0.,sdf);
      float outline =  outside - inside;
      
      float lines = 0.1; 
      float lineThreshold = 0.25;
      float mountains = makeLine(fract(sdf  * 10. )*  inside - 1., 0.2) * smoothstep(-lineThreshold,-lineThreshold - 0.1, sdf);
      vec3 color = vec3(thinShadows * (1.-outside) + outline  );
      // color  = vec3(step(scene(uv)));
      // color = vec3(scene(uv));
      // color = vec3(smoothstep(0.02,0.,sdf));
      // color = vec3(smoothstep(0.05,0.,sdf) - inside);
      gl_FragColor = vec4(vec3(1.), color.r);
    }
  </script>
  <script id="vertex" type="x-shader/x-fragment">
    #define PI 3.14159265358979323846
    varying vec2 vUv;
    void main(){
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.);
      vUv = uv;
    }
  </script>
  <script id="util-noise" type="x-shader/x-fragment">

  //
  // Description : Array and textureless GLSL 2D/3D/4D simplex
  //               noise functions.
  //      Author : Ian McEwan, Ashima Arts.
  //  Maintainer : ijm
  //     Lastmod : 20110822 (ijm)
  //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
  //               Distributed under the MIT License. See LICENSE file.
  //               https://github.com/ashima/webgl-noise
  //
  
  vec3 mod289(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
  }
  
  vec4 mod289(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
  }
  
  vec4 permute(vec4 x) {
    return mod289(((x*34.0)+1.0)*x);
  }
  
  vec4 taylorInvSqrt(vec4 r){
    return 1.79284291400159 - 0.85373472095314 * r;
  }
  
  float snoise(vec3 v) {
  
    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
  
    // First corner
    vec3 i  = floor(v + dot(v, C.yyy) );
    vec3 x0 =   v - i + dot(i, C.xxx) ;
  
    // Other corners
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min( g.xyz, l.zxy );
    vec3 i2 = max( g.xyz, l.zxy );
  
    //   x0 = x0 - 0.0 + 0.0 * C.xxx;
    //   x1 = x0 - i1  + 1.0 * C.xxx;
    //   x2 = x0 - i2  + 2.0 * C.xxx;
    //   x3 = x0 - 1.0 + 3.0 * C.xxx;
    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y
  
    // Permutations
    i = mod289(i);
    vec4 p = permute( permute( permute(
        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
      + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
      + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
  
    // Gradients: 7x7 points over a square, mapped onto an octahedron.
    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
    float n_ = 0.142857142857; // 1.0/7.0
    vec3  ns = n_ * D.wyz - D.xzx;
  
    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)
  
    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
  
    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);
  
    vec4 b0 = vec4( x.xy, y.xy );
    vec4 b1 = vec4( x.zw, y.zw );
  
    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));
  
    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
  
    vec3 p0 = vec3(a0.xy,h.x);
    vec3 p1 = vec3(a0.zw,h.y);
    vec3 p2 = vec3(a1.xy,h.z);
    vec3 p3 = vec3(a1.zw,h.w);
  
    //Normalise gradients
    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;
  
    // Mix final noise value
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
  
  }
    
  // via: https://petewerner.blogspot.jp/2015/02/intro-to-curl-noise.html
  vec3 curlNoise( vec3 p ){
  
    const float e = 0.1;
  
    float  n1 = snoise(vec3(p.x, p.y + e, p.z));
    float  n2 = snoise(vec3(p.x, p.y - e, p.z));
    float  n3 = snoise(vec3(p.x, p.y, p.z + e));
    float  n4 = snoise(vec3(p.x, p.y, p.z - e));
    float  n5 = snoise(vec3(p.x + e, p.y, p.z));
    float  n6 = snoise(vec3(p.x - e, p.y, p.z));
  
    float x = n2 - n1 - n4 + n3;
    float y = n4 - n3 - n6 + n5;
    float z = n6 - n5 - n2 + n1;
  
  
    const float divisor = 1.0 / ( 2.0 * e );
    return normalize( vec3( x , y , z ) * divisor );
  }
    
  </script>
  <script>
    console.clear();
    let options = {
      shaderUtils: ['simplex'],
      width: 20,
      height: 20,
      useGUI: false
    }
    class App {
      constructor() {
        const config = {
          movement: 'controlled',
          style: 'padded',
          // light: 'controlled'
        }
        this.config = config;
        const renderer = new THREE.WebGLRenderer({ antialias: true, canvas: islands });
        renderer.setSize(window.innerWidth, window.innerHeight);

        const VIEW_ANGLE = 45,
          ASPECT = window.innerWidth / window.innerHeight,
          NEAR = 0.1,
          FAR = 10000;
        const camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
        camera.position.z = 20;

        const scene = new THREE.Scene();

        this.raycaster = new THREE.Raycaster();




        this.camera = camera;
        this.scene = scene;
        this.renderer = renderer;
        this.plane = null;
        this.clock = new THREE.Clock();
        this.uniforms = {
          uTime: new THREE.Uniform(0),
          uMouse: new THREE.Uniform(new THREE.Vector2(0, 0)),
          uScreenMouse: new THREE.Uniform(new THREE.Vector2(0, 0)),
          oStyle: new THREE.Uniform(1),
          oMovement: new THREE.Uniform(0),
        }
        this.tick = this.tick.bind(this);


        window.addEventListener('resize', this.onResize.bind(this));
        window.addEventListener('mousemove', this.onMouseMove.bind(this));
        this.init();
      }
      init() {
        const geometry = new THREE.PlaneBufferGeometry(options.width, options.height, 1, 1);
        let fragment = document.getElementById('fragment').textContent;
        fragment = getShaderUtils(options.shaderUtils) + fragment;
        const material = new THREE.ShaderMaterial({
          uniforms: this.uniforms,
          fragmentShader: fragment,
          vertexShader: document.getElementById('vertex').textContent,
          transparent: true
        });
        const mesh = new THREE.Mesh(geometry, material);
        this.plane = mesh;
        this.scene.add(mesh);
        if (options.useGUI)
          this.initGUI();
        this.tick();
      }
      initGUI() {
        this.gui = new dat.GUI();
      }
      tick() {
        this.uniforms.uTime.value = this.clock.getElapsedTime();
        this.uniforms.uTime.needsUpdate = true;
        this.renderer.render(this.scene, this.camera);
        requestAnimationFrame(this.tick);
      }
      onResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();

        this.renderer.setSize(window.innerWidth, window.innerHeight);
      }
      onMouseMove(ev) {
        let mouse = {
          x: (ev.clientX / window.innerWidth) * 2 - 1,
          y: - (ev.clientY / window.innerHeight) * 2 + 1
        }
        this.uniforms.uScreenMouse.value.set(mouse.x * 0.5 + 0.5, mouse.y * 0.5 + 0.5);
        this.uniforms.uScreenMouse.needsUpdate = true;
        const raycaster = this.raycaster;
        raycaster.setFromCamera(mouse, this.camera);
        var intersects = raycaster.intersectObjects(this.scene.children);
        if (intersects.length > 0) {
          let obj = intersects[0];
          this.uniforms.uMouse.value.set(obj.uv.x, obj.uv.y);
          this.uniforms.uMouse.needsUpdate = true;
        }
      }
    }

    const shaders = {
      simplex: document.getElementById('util-noise').textContent
    }
    const getShaderUtils = (keys) => {
      return keys.reduce((res, key) => res + shaders[key], '')
    }
    const myApp = new App();
  </script>
</body>

</html>